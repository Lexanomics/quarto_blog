{
  "hash": "775deba06082783acfda315b74798aa0",
  "result": {
    "markdown": "---\ntitle: \"Creating a PPI network from a list of differentially expressed genes\"\nauthor: \"Iara Souza\"\ndate: \"2024-04-09\"\nfreeze: auto\nexecute: \n  warning: false\ncategories: [debbuging new]\n---\n\n::: {.cell}\n\n:::\n\n\nSuppose that we have a set of differentially expressed genes (DEG) from RNA-Seq data and their corresponding log2FoldChanges. Let's create a protein-protein interaction (PPI) network with StringDB. By combining PPI information and gene expression, we can have insights about how the DEGs can impact (or be impacted by) other genes. \n\nYou can download the data from this tutorial [here](https://drive.google.com/file/d/1J9Qe7noH_kK6NDOrv7v2c5bjAQKfmPv5/view?usp=sharing).\n\n![](fig3.png)\n\n## Step 1: Retrieve the PPI network from StringDB\n\nBefore starting, you'll need to install and load the following packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(RedeR)\nlibrary(igraph)\n```\n:::\n\n\nLet's import the table with the DEGs. In this table there is a column for gene symbols and another column for their corresponding log2FoldChanges. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndegs <- read.csv(\"exp-table.csv\")\nhead(degs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   genes     log2fc\n1   ACLY  0.6864199\n2   ACO1 -1.4629591\n3   ACO2 -3.7851444\n4     CS  2.0569852\n5 DHTKD1  3.0715545\n6   DLAT  1.8612732\n```\n:::\n:::\n\n\nWe're using the stringDB API to retrieve PPI information (for more information of each API's methods, visit [https://string-db.org/help/api/](https://string-db.org/help/api/)).\n\nThe first method to be used is the `get_string_ids`, which will map a list of genes to the stringDB's identifiers ([https://string-db.org/cgi/help.pl?subpage=api%23mapping-identifiers](https://string-db.org/cgi/help.pl?subpage=api%23mapping-identifiers).\n\nWhen submitting a request to the stringDB API programmatically, we need to concatenate the identifiers by the symbol \"%0d\" (this is the standard separator for gene names).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenes <- paste0(degs$genes, collapse = \"%0d\")\n```\n:::\n\n\nNow we can make a request with the `postForm` function from the `RCurl` package. An important parameter is the `species`, which stands for the NCBI taxonomy ID for the genes/proteins we're considering. In this case, we are dealing with human genes (taxid: 9606). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nreq <- RCurl::postForm(\n  \"https://string-db.org/api/tsv/get_string_ids\",\n  identifiers = genes, # gene names\n  echo_query = \"1\",\n  species = \"9606\" # homo sapiens taxid\n)\nids_mapped <- read.table(text = req, sep = \"\\t\", header = T, quote = \"\")\n\nhead(ids_mapped[,1:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  queryItem queryIndex             stringId\n1      ACLY          0 9606.ENSP00000466259\n2      ACO1          1 9606.ENSP00000309477\n3      ACO2          2 9606.ENSP00000216254\n4        CS          3 9606.ENSP00000342056\n5    DHTKD1          4 9606.ENSP00000263035\n6      DLAT          5 9606.ENSP00000280346\n```\n:::\n:::\n\n\nWe mapped each gene name to their corresponding proteins annotated on the StringDB (the `stringId` column). Now, let's use these StringIDs to retrieve the interaction information:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringids <- paste0(unique(ids_mapped$stringId), collapse = \"%0d\")\n\nreq <- RCurl::postForm(\n  \"https://string-db.org/api/tsv/network\",\n  identifiers = stringids, # stringids \n  required_core = \"0\", # minimal score\n  species     = \"9606\"  # homo sapiens taxid\n)\n\nppi <- read.table(text = req, sep = \"\\t\", header = T)\nhead(ppi[,1:2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            stringId_A           stringId_B\n1 9606.ENSP00000216254 9606.ENSP00000258886\n2 9606.ENSP00000216254 9606.ENSP00000223366\n3 9606.ENSP00000216254 9606.ENSP00000297283\n4 9606.ENSP00000216254 9606.ENSP00000295266\n5 9606.ENSP00000216254 9606.ENSP00000290573\n6 9606.ENSP00000216254 9606.ENSP00000264663\n```\n:::\n:::\n\n\nThe dataframe represents a network format called **edge list**. It represents the interaction between the proteins on the `stringId_A` column and the proteins on the `stringId_B` columns. For example, the protein 9606.ENSP00000216254 interacts with the protein 9606.ENSP00000258886. The interaction information of a given protein A and a protein B comes from different sources (also called channels). StringDB returns the following channels:\n\n`score`: combined score  \n`nscore`: gene neighborhood score  \n`fscore`: gene fusion score  \n`pscore`: phylogenetic profile score  \n`ascore`: coexpression score  \n`escore`: experimental score  \n`dscore`: database score  \n`tscore`: textmining score  \n\nAs you guessed, the combined score represents the score combination of all other channels. We then can select the interactions based on a combined score of 0.7 (you can choose other channels as a reference for the interactions):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nppi <- subset(ppi, ppi$score >= 0.7)\nnrow(ppi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 375\n```\n:::\n:::\n\n\nThis leaves us with 375 interactions reported for the proteins retrieved from our initial DEGs list.\n\n## Step 2: Plot the PPI network with `RedeR`\n\n`RedeR` is an R/Bioconductor package suitable to plot and manipulate networks. It presents a friendly interface to facilitate network customization (See the [vignette](https://bioconductor.org/packages/release/bioc/vignettes/RedeR/inst/doc/RedeR.html) for the complete guideline).\n\nFirst, let's create a dataframe holding the information regarding each gene, their associated protein and the log2FC:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nannotation <- merge(degs,\n                    ids_mapped[, c(\"queryItem\", \"stringId\")],\n                    by.x = \"genes\", \n                    by.y = \"queryItem\")\nhead(annotation)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   genes     log2fc             stringId\n1   ACLY  0.6864199 9606.ENSP00000466259\n2   ACO1 -1.4629591 9606.ENSP00000309477\n3   ACO2 -3.7851444 9606.ENSP00000216254\n4     CS  2.0569852 9606.ENSP00000342056\n5 DHTKD1  3.0715545 9606.ENSP00000263035\n6   DLAT  1.8612732 9606.ENSP00000280346\n```\n:::\n:::\n\n\nNow, let's use the `igraph` package to create the network. `igraph` is a multilanguage API created to represent data as networks. If you want to know more about the `igraph` R interface, see their vignette: [https://r.igraph.org/](https://r.igraph.org/). Here, we used the `directed = FALSE` argument because PPI networks are undirected networks. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph <- igraph::graph_from_data_frame(ppi[, c(\"stringId_A\", \"stringId_B\")], directed = FALSE)\nplot(graph)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nThis is not great, the aesthetics can be improved. Now, let's associate the `annotation` data.frame we constructed before with the igraph object we created:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph <- RedeR::att.mapv(graph, dat = annotation, refcol = 3)\n```\n:::\n\n\nThe `refcol` argument specifies which column on my `annotation` dataframe corresponds to the node ID used to build the graph (in this case, we used the stringID, the third column on the `annotation` dataframe). This is the reference column that will be used to set other attributes to our network. \n\nUsually, it is more informative to represent the nodes as gene names. Let's also color the nodes following the log2FC scale. To do that, let's set those attributes on the graph we created:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph <- RedeR::att.setv(graph, from = \"genes\", to = \"nodeAlias\")\ngraph <- RedeR::att.setv(graph, from = \"log2fc\", to = \"nodeColor\", breaks = seq(-2, 2, 0.4), pal = 2)\n```\n:::\n\n\nNow, we launch the `RedeR` interface and we add the network to it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrdp <- RedPort()\ncalld(rdp)\naddGraph(rdp, graph)\n```\n:::\n\n\nFrom there, you can play around with your network and dispose the nodes as you wish. Or you can hit the \"Start relax\" button and the `RedeR` will look for an optimal layout for your network. This is specially useful for big networks. You can test different force parameters and see how it affects your network layout. \n\n![](fig1.png)\n\nAt last, let's add a legend for color scale:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscl <- graph$legNodeColor$scale\nleg <- graph$legNodeColor$legend \naddLegend.color(rdp, \n                colvec = scl, \n                labvec = leg, \n                title = \"log2FC\")\n```\n:::\n\n\n![](fig2.png)\n\nAnd voilÃ ! You can save the network image by going in \"File\" > \"Export\" > \"Image\" and chosing the desired format. \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}