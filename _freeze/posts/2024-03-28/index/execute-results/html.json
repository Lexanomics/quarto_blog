{
  "hash": "ddbd6d20371265679ec8fa64553b563b",
  "result": {
    "markdown": "---\ntitle: \"\"\nauthor: \"Lexanomics\"\ndate: \"2024-03-28\"\nexecute:\n  warning: false\nfreeze: auto\ncategories: [debbuging new]\n---\n\n\n# Parallelization tips on Seurat\n\n:::: {.columns}\n\n::: {.column width=\"70%\"}\n\nFor the series on basic, but useful tips on single-cell analysis. We want to introduce parallelization using **future** for Seurat. \n\nFrequently a bioinformatician/computational biologist needs to test multiple parameters in a single-cell project, e.g., evaluating clustering resolutions. Although a conventional task, this procedure could take a while ranging from minutes to hours... It can get even worse if we talk about differential expressions analysis with well-known **FindAllMarkers**. \n\nLife is short, and I want my results. That being said, why not use parallelization? To our surprise, not many data analysts are familiar with the **future** package \\[[1](https://cran.r-project.org/web/packages/future/index.html)\\]. Furthermore, the future package is very handy for R package development - *Yes, it is not limited to Seurat, you could incorporate it into your package/script*. \n\n:::\n\n::: {.column width=\"30%\"}\n![](future_seurat.png){heigh=140% width=140% fig-align=\"right\"}\n:::\n\n::::\n\nAs for Seurat, there are at least six (06) functions that were written to leverage **future** parallelization.\n\n-   NormalizeData\n-   ScaleData -JackStraw\n-   FindMarkers\\*\n-   FindIntegrationAnchors\n-   FindClusters\\*\n\n\\**For teaching purposes we will focus only on these two functions.*\n\n## 1. Loading requirements\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Seurat)\nlibrary(dplyr)\nlibrary(future)\n```\n:::\n\n\nPlease note that we need to establish what parallelization strategy (plan) will be used in our analysis. Also, we are running multiple processes in parallel which can dramatically increase the memory consumption. Be thoughtful about it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Setting memory limit for 8Gb\noptions(future.globals.maxSize = 8000 * 1024^2)\n\n# Enabling parallelization\nplan(\"multicore\", workers = 4) # To the date, RStudio does not support parallelization. Run this script using Rscript command-line application.\n```\n:::\n\n\nNext, we will load the PBMC dataset from 10X Genomics. Available [here](https://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz)\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npbmc_seurat <- readRDS(file = \"path/to/pbmc_seurat.RDS\")\npbmc_seurat\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n13714 features across 2700 samples within 1 assay \nActive assay: RNA (13714 features, 2000 variable features)\n 3 layers present: counts, data, scale.data\n```\n:::\n:::\n\n\n## 2. Normalization and Dimensionality reduction\n\n\n::: {.cell}\n\n```{.r .cell-code}\npbmc_seurat <- pbmc_seurat %>%\n  NormalizeData(normalization.method = \"LogNormalize\", scale.factor = 10000) %>%\n  FindVariableFeatures(selection.method = \"vst\", nfeatures = 2000) %>%\n  ScaleData()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npbmc_seurat <- RunPCA(pbmc_seurat)\n```\n:::\n\n\n## 3. Clustering\n\nAs mentioned, often a bioinformatician will evaluate with multiple clustering resolutions. In this tutorial, we will do such a task considering eight different thresholds.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npbmc_seurat <- FindNeighbors(pbmc_seurat, dims = 1:10)\npbmc_seurat <- FindClusters(pbmc_seurat, \n                            resolution = c(0.1, 0.25, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0))\n```\n:::\n\n\n## 4. Differential Expression\n\nFinally, we will execute the differential expression analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npbmc_markers <- FindAllMarkers(pbmc_seurat, only.pos = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npbmc_markers %>%\n    group_by(cluster) %>%\n    dplyr::filter(avg_log2FC > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,830 × 7\n# Groups:   cluster [11]\n      p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene     \n      <dbl>      <dbl> <dbl> <dbl>     <dbl> <fct>   <chr>    \n 1 4.62e-91       1.08 0.954 0.609  6.33e-87 0       LDHB     \n 2 1.94e-89       2.11 0.517 0.124  2.66e-85 0       CCR7     \n 3 1.68e-52       1.76 0.396 0.117  2.30e-48 0       PRKCQ-AS1\n 4 9.77e-52       1.83 0.388 0.114  1.34e-47 0       LEF1     \n 5 1.77e-43       1.89 0.323 0.09   2.42e-39 0       MAL      \n 6 2.61e-43       2.05 0.235 0.048  3.58e-39 0       FHIT     \n 7 3.45e-42       1.37 0.488 0.196  4.74e-38 0       PIK3IP1  \n 8 1.41e-40       1.05 0.677 0.373  1.93e-36 0       NOSIP    \n 9 1.51e-37       1.20 0.448 0.184  2.08e-33 0       TCF7     \n10 1.83e-35       1.57 0.244 0.063  2.51e-31 0       TRABD2A  \n# ℹ 2,820 more rows\n```\n:::\n:::\n\n\n**Another lazy tip**: If you are interested in assessing a *preliminary* result, you could combine the parallelization strategy with the parameter **max.cells.per.ident** from FindAllMarkers. It will downsample each cluster/ident based on the selected threshold.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npbmc_markers <- FindAllMarkers(\n  pbmc_seurat, \n  max.cells.per.ident = 100, # for real datasets you should considered 1000 cells\n  only.pos = TRUE)\n```\n:::\n\n\n------------------------------------------------------------------------\n\n* The figures are derived from [1](https://satijalab.org/seurat/articles/install), and [2](https://github.com/HenrikBengtsson/future)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}